---
# 1Password CLI Security Enhancement Module
# Provides comprehensive security features for 1Password CLI operations

- name: Ensure 1Password CLI security requirements directory exists
  ansible.builtin.file:
    path: "{{ ansible_env.HOME }}/.config/op"
    state: directory
    mode: "0700"
    owner: "{{ ansible_user_id }}"

- name: Create 1Password CLI timeout wrapper script
  ansible.builtin.copy:
    dest: "{{ ansible_env.HOME }}/.local/bin/op-secure"
    mode: "0755"
    content: |
      #!/bin/bash
      # 1Password CLI Security Wrapper
      # Provides timeout handling, session management, and error recovery

      set -euo pipefail

      # Configuration
      readonly OP_TIMEOUT="${OP_TIMEOUT:-30}"
      readonly OP_SESSION_FILE="${HOME}/.config/op/session"
      readonly OP_LOG_FILE="${HOME}/.config/op/op-secure.log"
      readonly MAX_RETRIES="${OP_MAX_RETRIES:-3}"

      # Colors for output
      readonly RED='\033[0;31m'
      readonly GREEN='\033[0;32m'
      readonly YELLOW='\033[1;33m'
      readonly NC='\033[0m' # No Color

      # Logging function
      log() {
          local level="$1"
          shift
          echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $*" >> "$OP_LOG_FILE"
          case "$level" in
              ERROR) echo -e "${RED}[ERROR]${NC} $*" >&2 ;;
              WARN) echo -e "${YELLOW}[WARN]${NC} $*" >&2 ;;
              INFO) echo -e "${GREEN}[INFO]${NC} $*" ;;
          esac
      }

      # Session management functions
      is_session_valid() {
          if [[ ! -f "$OP_SESSION_FILE" ]]; then
              return 1
          fi

          local session_token
          session_token=$(cat "$OP_SESSION_FILE" 2>/dev/null || echo "")

          if [[ -z "$session_token" ]]; then
              return 1
          fi

          # Test session validity with a simple whoami call
          if timeout "$OP_TIMEOUT" op whoami --session "$session_token" >/dev/null 2>&1; then
              return 0
          else
              log "WARN" "Session token expired or invalid"
              rm -f "$OP_SESSION_FILE"
              return 1
          fi
      }

      create_new_session() {
          log "INFO" "Creating new 1Password session"

          local session_token
          if session_token=$(timeout "$OP_TIMEOUT" op signin --raw 2>/dev/null); then
              echo "$session_token" > "$OP_SESSION_FILE"
              chmod 600 "$OP_SESSION_FILE"
              log "INFO" "New session created successfully"
              return 0
          else
              log "ERROR" "Failed to create new session"
              return 1
          fi
      }

      get_session_token() {
          if is_session_valid; then
              cat "$OP_SESSION_FILE"
          else
              if create_new_session; then
                  cat "$OP_SESSION_FILE"
              else
                  return 1
              fi
          fi
      }

      # Enhanced op command wrapper with retries and timeout
      op_secure_command() {
          local retry_count=0
          local session_token

          while (( retry_count < MAX_RETRIES )); do
              if session_token=$(get_session_token); then
                  log "INFO" "Executing op command: $*"

                  if timeout "$OP_TIMEOUT" op "$@" --session "$session_token"; then
                      log "INFO" "Command completed successfully"
                      return 0
                  else
                      local exit_code=$?
                      log "WARN" "Command failed with exit code $exit_code (attempt $((retry_count + 1))/$MAX_RETRIES)"

                      # If authentication failed, remove session and retry
                      if (( exit_code == 1 )); then
                          log "WARN" "Authentication failure detected, removing session"
                          rm -f "$OP_SESSION_FILE"
                      fi
                  fi
              else
                  log "ERROR" "Failed to obtain valid session token"
              fi

              ((retry_count++))
              if (( retry_count < MAX_RETRIES )); then
                  local wait_time=$((retry_count * 2))
                  log "INFO" "Waiting ${wait_time} seconds before retry..."
                  sleep "$wait_time"
              fi
          done

          log "ERROR" "Command failed after $MAX_RETRIES attempts"
          return 1
      }

      # CLI version validation
      validate_cli_version() {
          log "INFO" "Validating 1Password CLI version"

          local current_version
          if ! current_version=$(timeout 10 op --version 2>/dev/null); then
              log "ERROR" "Failed to get 1Password CLI version"
              return 1
          fi

          log "INFO" "Current 1Password CLI version: $current_version"

          # Extract version number (format: 2.x.x)
          local version_number
          version_number=$(echo "$current_version" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)

          if [[ -z "$version_number" ]]; then
              log "ERROR" "Could not parse version number from: $current_version"
              return 1
          fi

          # Check if version is at least 2.0.0 (minimum secure version)
          if [[ $(echo "$version_number" | cut -d. -f1) -lt 2 ]]; then
              log "ERROR" "1Password CLI version $version_number is too old (minimum: 2.0.0)"
              return 1
          fi

          log "INFO" "1Password CLI version validation passed"
          return 0
      }

      # Keyring permission validation
      validate_keyring_permissions() {
          log "INFO" "Validating keyring file permissions"

          local config_dir="${HOME}/.config/op"

          # Validate directory permissions
          if [[ -d "$config_dir" ]]; then
              local dir_perms
              dir_perms=$(stat -c %a "$config_dir" 2>/dev/null || stat -f %A "$config_dir" 2>/dev/null)
              if [[ "$dir_perms" != "700" ]]; then
                  log "WARN" "Fixing directory permissions for $config_dir (was: $dir_perms)"
                  chmod 700 "$config_dir"
              fi
          fi

          # Validate session file permissions
          if [[ -f "$OP_SESSION_FILE" ]]; then
              local file_perms
              file_perms=$(stat -c %a "$OP_SESSION_FILE" 2>/dev/null || stat -f %A "$OP_SESSION_FILE" 2>/dev/null)
              if [[ "$file_perms" != "600" ]]; then
                  log "WARN" "Fixing file permissions for $OP_SESSION_FILE (was: $file_perms)"
                  chmod 600 "$OP_SESSION_FILE"
              fi
          fi

          log "INFO" "Keyring permission validation completed"
      }

      # Main function
      main() {
          # Ensure log directory exists
          mkdir -p "$(dirname "$OP_LOG_FILE")"

          # Validate CLI version
          if ! validate_cli_version; then
              exit 1
          fi

          # Validate permissions
          validate_keyring_permissions

          if [[ $# -eq 0 ]]; then
              echo "Usage: $0 <op-command> [args...]"
              echo "Example: $0 item get 'My Login'"
              exit 1
          fi

          # Execute the op command securely
          op_secure_command "$@"
      }

      # Handle special commands
      case "${1:-}" in
          --validate)
              validate_cli_version && validate_keyring_permissions
              ;;
          --session-status)
              if is_session_valid; then
                  log "INFO" "Session is valid"
                  exit 0
              else
                  log "INFO" "Session is invalid or missing"
                  exit 1
              fi
              ;;
          --clear-session)
              rm -f "$OP_SESSION_FILE"
              log "INFO" "Session cleared"
              ;;
          *)
              main "$@"
              ;;
      esac

- name: Create 1Password CLI health check script
  ansible.builtin.copy:
    dest: "{{ ansible_env.HOME }}/.local/bin/op-health-check"
    mode: "0755"
    content: |
      #!/bin/bash
      # 1Password CLI Health Check Script
      # Performs comprehensive health checks for 1Password CLI setup

      set -euo pipefail

      # Colors for output
      readonly RED='\033[0;31m'
      readonly GREEN='\033[0;32m'
      readonly YELLOW='\033[1;33m'
      readonly BLUE='\033[0;34m'
      readonly NC='\033[0m' # No Color

      # Health check results
      declare -i TOTAL_CHECKS=0
      declare -i PASSED_CHECKS=0
      declare -i FAILED_CHECKS=0
      declare -i WARNING_CHECKS=0

      # Logging functions
      check_start() {
          echo -e "${BLUE}🔍 Checking: $1${NC}"
          ((TOTAL_CHECKS++))
      }

      check_pass() {
          echo -e "${GREEN}✅ PASS: $1${NC}"
          ((PASSED_CHECKS++))
      }

      check_fail() {
          echo -e "${RED}❌ FAIL: $1${NC}"
          ((FAILED_CHECKS++))
      }

      check_warn() {
          echo -e "${YELLOW}⚠️  WARN: $1${NC}"
          ((WARNING_CHECKS++))
      }

      # Individual health checks
      check_cli_installation() {
          check_start "1Password CLI installation"

          if command -v op >/dev/null 2>&1; then
              local version
              version=$(op --version 2>/dev/null || echo "unknown")
              check_pass "1Password CLI installed (version: $version)"
              return 0
          else
              check_fail "1Password CLI not found in PATH"
              return 1
          fi
      }

      check_cli_version() {
          check_start "1Password CLI version compatibility"

          if ! command -v op >/dev/null 2>&1; then
              check_fail "Cannot check version - CLI not installed"
              return 1
          fi

          local version
          version=$(op --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)

          if [[ -z "$version" ]]; then
              check_fail "Could not determine CLI version"
              return 1
          fi

          local major_version
          major_version=$(echo "$version" | cut -d. -f1)

          if (( major_version >= 2 )); then
              check_pass "CLI version $version is compatible"
              return 0
          else
              check_fail "CLI version $version is too old (minimum: 2.0.0)"
              return 1
          fi
      }

      check_directory_permissions() {
          check_start "Configuration directory permissions"

          local config_dir="${HOME}/.config/op"

          if [[ ! -d "$config_dir" ]]; then
              check_warn "Configuration directory does not exist: $config_dir"
              return 1
          fi

          local perms
          perms=$(stat -c %a "$config_dir" 2>/dev/null || stat -f %A "$config_dir" 2>/dev/null)

          if [[ "$perms" == "700" ]]; then
              check_pass "Directory permissions are secure (700)"
              return 0
          else
              check_fail "Directory permissions are insecure: $perms (should be 700)"
              return 1
          fi
      }

      check_session_file_security() {
          check_start "Session file security"

          local session_file="${HOME}/.config/op/session"

          if [[ ! -f "$session_file" ]]; then
              check_warn "No session file found (will be created when needed)"
              return 0
          fi

          local perms
          perms=$(stat -c %a "$session_file" 2>/dev/null || stat -f %A "$session_file" 2>/dev/null)

          if [[ "$perms" == "600" ]]; then
              check_pass "Session file permissions are secure (600)"
              return 0
          else
              check_fail "Session file permissions are insecure: $perms (should be 600)"
              return 1
          fi
      }

      check_wrapper_scripts() {
          check_start "Security wrapper scripts"

          local op_secure="${HOME}/.local/bin/op-secure"

          if [[ -f "$op_secure" && -x "$op_secure" ]]; then
              check_pass "op-secure wrapper script is installed and executable"
              return 0
          else
              check_fail "op-secure wrapper script is missing or not executable"
              return 1
          fi
      }

      check_authentication() {
          check_start "1Password authentication status"

          if command -v op >/dev/null 2>&1; then
              if timeout 10 op whoami >/dev/null 2>&1; then
                  local account
                  account=$(op whoami --format=json 2>/dev/null | jq -r '.email // .user_uuid // "unknown"' 2>/dev/null || echo "authenticated")
                  check_pass "Successfully authenticated as: $account"
                  return 0
              else
                  check_warn "Not currently authenticated (run 'op signin' to authenticate)"
                  return 1
              fi
          else
              check_fail "Cannot check authentication - CLI not available"
              return 1
          fi
      }

      # Main health check function
      main() {
          echo -e "${BLUE}🔐 1Password CLI Security Health Check${NC}"
          echo "======================================="
          echo ""

          # Run all checks
          check_cli_installation
          check_cli_version
          check_directory_permissions
          check_session_file_security
          check_wrapper_scripts
          check_authentication

          # Summary
          echo ""
          echo -e "${BLUE}📊 Health Check Summary${NC}"
          echo "======================"
          echo -e "Total checks: $TOTAL_CHECKS"
          echo -e "${GREEN}Passed: $PASSED_CHECKS${NC}"
          echo -e "${YELLOW}Warnings: $WARNING_CHECKS${NC}"
          echo -e "${RED}Failed: $FAILED_CHECKS${NC}"

          if (( FAILED_CHECKS == 0 && WARNING_CHECKS == 0 )); then
              echo -e "\n${GREEN}🎉 All checks passed! Your 1Password CLI setup is secure.${NC}"
              exit 0
          elif (( FAILED_CHECKS == 0 )); then
              echo -e "\n${YELLOW}⚠️  Setup is mostly secure but has warnings to address.${NC}"
              exit 1
          else
              echo -e "\n${RED}❌ Setup has security issues that need immediate attention.${NC}"
              exit 2
          fi
      }

      main "$@"

- name: Validate secure keyring file permissions
  ansible.builtin.file:
    path: "{{ item }}"
    mode: "0600"
    owner: "{{ ansible_user_id }}"
    state: touch
  loop:
    - "{{ ansible_env.HOME }}/.config/op/session"
  when: item is file

- name: Create 1Password CLI security configuration (shell format for our scripts)
  ansible.builtin.copy:
    dest: "{{ ansible_env.HOME }}/.config/op/security-config"
    mode: "0600"
    content: |
      # 1Password CLI Security Configuration
      # This file contains security settings for our wrapper scripts

      # Session timeout (in seconds)
      SESSION_TIMEOUT=1800

      # Maximum retry attempts for failed operations
      MAX_RETRIES=3

      # Enable secure logging (logs to ~/.config/op/op-secure.log)
      ENABLE_LOGGING=true

      # Require biometric authentication when available
      REQUIRE_BIOMETRIC=false

      # Auto-lock session after inactivity (in seconds)
      AUTO_LOCK_TIMEOUT=3600
